% ------------------------------------------------
% *** Section 1: Introduction ***
% ------------------------------------------------
\newpage
\chapter{Introduction}
\section{Getting Started}
% Perhaps, move this block after building and running AstraKernel subsection
AstraKernel begins its life in a small bootstrap routine, written in ARM assembly,
that prepares the processor’s state before passing control to the main C kernel.
This bootstrap code programs the exception vector base, sets up mode-specific
stacks (SVC/IRQ/FIQ/ABT/UND), initializes \texttt{.data}, clears \texttt{.bss},
and ensures a clean environment for the kernel’s entry point. Below is a trimmed
excerpt of the current startup sequence: \\

\begin{lstlisting}[language={C}, caption={Bootstrap excerpt for AstraKernel.}, label={lst:bootstrap}]
    .section .vectors
    .global _start
_start:
    // Switch to SVC, mask IRQ/FIQ
    MRS     R0, cpsr
    BIC     R0, R0, #0x1F
    ORR     R0, R0, #0x13
    ORR     R0, R0, #(1 << 7)
    ORR     R0, R0, #(1 << 6)
    MSR     cpsr_c, R0

    // Point VBAR at the vector table
    LDR     R0, =vectors_base
    MCR     P15, 0, R0, C12, C0, 0
    ISB

    // Set mode stacks (SVC/IRQ/FIQ/ABT/UND)
    LDR     sp, =__stack_top__
    // ... switch modes and set stack pointers ...

    // Copy .data from LMA to VMA
    LDR     R0, =__data_load
    LDR     R1, =__data_start
    LDR     R2, =__data_end
    // ... copy loop ...

    // Clear .bss
    LDR     R0, =__bss_start
    LDR     R1, =__bss_end
    MOV     R2, #0
    // ... zero loop ...

    BL      kernel_main
\end{lstlisting}

This startup sequence is the essential first step for any kernel, ensuring the
CPU is properly initialized and memory is in a known state before higher-level
code takes over. Once these preparations are complete, the \texttt{kernel\_main}
function from \texttt{src/kernel/kernel.c} is called, marking the transition from
low-level assembly to the C code that forms the core of AstraKernel.

\subsection{Prerequisites}

Before you can build and run AstraKernel, please ensure you have the following 
tools installed on your system:

\begin{itemize}
  \item \textbf{ARM Cross-Compiler:}  
  A cross-compiler targeting ARM is required to build the kernel. It 
  is recommended to use \texttt{arm-none-eabi-gcc}, \texttt{arm-none-eabi-ld}, 
  and \texttt{arm-none-eabi-objcopy} for Cortex-A8 processor with ARMv7-A, which is the target architecture
  for AstraKernel.
  \begin{itemize}
    \item Example installation: \texttt{arm-none-eabi-xxx} (available via package 
    managers such as \texttt{brew}, \texttt{apt}, or direct download from ARM's website).
  \end{itemize}
  
  \item \textbf{QEMU Emulator:}  
  QEMU is used to emulate the ARM VersatileAB (Cortex-A8) platform for kernel development and testing.
  \begin{itemize}
    \item Ensure your QEMU installation supports the \texttt{versatileab} machine.
    \item Example installation: \texttt{qemu-system-arm} via  qemu \url{https://www.qemu.org/download/}.
  \end{itemize}

  \item \textbf{Build Tools:}  
  Standard build tools such as \texttt{make} are required to compile the kernel.
  \begin{itemize}
    \item Example installation: \texttt{make} (available via package managers 
    such as \texttt{brew}, \texttt{apt}, or direct download \url{https://www.gnu.org/software/make/#download}).
  \end{itemize}
\end{itemize}

\noindent
For best results, ensure all tools are up-to-date. Consult the official documentation 
of each tool for installation instructions on your operating system.

\subsection{Building \& Running AstraKernel}

\begin{note}
  The following instructions assume you have the necessary tools installed on your 
  system as mentioned in the prerequisites.
\end{note}

This project uses \texttt{Make} to automate the build process. The configuration
is located in the \texttt{Makefile} in the root directory of the kernel source code.
To build and run the kernel, navigate to the root directory of the AstraKernel source code
and execute the following command in your terminal: \\

\begin{lstlisting}[language={bash}, caption={Building AstraKernel.}, label={lst:build}]
make
\end{lstlisting}

\noindent
This command invokes the Makefile, which automatically compiles the kernel 
source code, links the object files, and generates the final kernel binary. The 
output files are placed in the \texttt{build/} directory, and any previously 
compiled files there are removed to ensure a clean build environment. Finally, 
the commands also run \texttt{make qemu}, which launches the QEMU emulator with the 
built kernel image. \\

\begin{lstlisting}[language={make}, caption={Makefile for AstraKernel.}, label={lst:makefile}]
  # Assembly start.o goes to build/
  $(OUT_DIR)start.o: src/kernel/start.s
    @mkdir -p $(OUT_DIR)
    $(AS) -c $< -o $@

  # Pattern rule for any .c -> build/*.o
  $(OUT_DIR)%.o: %.c
    @mkdir -p $(OUT_DIR)
    $(CC) $(CFLAGS) -c $< -o $@ $(KFLAGS)

  # Link everything
  $(OUT_DIR)kernel.elf: $(OUT_DIR)start.o $(OBJS) kernel.ld
    $(LD) $(LDFLAGS) $(OUT_DIR)start.o $(OBJS) -o $@

  # Generate the kernel binary from the ELF file
  kernel.bin: $(OUT_DIR)kernel.elf
    $(OBJCOPY) -O binary $< $(OUT_DIR)$@
\end{lstlisting}

\begin{info}
  You can run each \texttt{make} target on its own. Run \texttt{make kernel.bin} 
  to compile the kernel binary, \texttt{make qemu} to launch the built kernel in 
  QEMU, and \texttt{make clean} to remove all object files and the \texttt{kernel.bin} 
  from the \texttt{build/} directory.
\end{info}

\subsection{Build Modes}
\paragraph{Overview}
The Makefile provides a couple of build-time options to enable tests and
instrumentation. These are passed via \texttt{KFLAGS}.

\begin{itemize}
  \item \texttt{USE\_KTESTS}: enable the kernel test suite
  (see \texttt{src/kernel/tests/test\_memory.c}).
  \item \texttt{KLOG\_USE\_TICKS}: include tick counts in \texttt{KLOG} output
  and start the timer/IRQs early in \texttt{kernel\_main()}.
\end{itemize}

\paragraph{Examples}
\begin{lstlisting}[language=bash, caption={Build modes.}]
  # Run kernel tests
  make KFLAGS="-DUSE_KTESTS"

  # Enable tick timestamps in logs
  make KFLAGS="-DKLOG_USE_TICKS"
\end{lstlisting}

\noindent
If the build is successful, you will see the output similar to the following:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{figures/bootedKernel.png}
  \caption{AstraKernel booted in QEMU.}
  \label{fig:bootedKernel}
\end{figure}

\subsection{Codebase's Overview}
\begin{itemize}
  \item \texttt{src/kernel/}: core kernel code (boot, interrupts, memory, panic, errno).
  \item \texttt{src/user/}: basic user-facing utilities (printf, string, datetime, clear).
  \item \texttt{src/kernel/tests/}: kernel tests (currently \texttt{kmalloc}).
  \item \texttt{include/}: public headers for kernel and user modules.
  \item \texttt{kernel.ld}: linker script and memory layout (vectors, text, rodata, data, bss, heap, stacks).
  \item \texttt{Makefile}: build rules and flags (including \texttt{KFLAGS}).
  \item \texttt{doc/}: LaTeX source for the kernel manual; \texttt{docs/} contains generated docs.
  \item \texttt{docs/pages/}: short markdown notes (panic, memory).
  \item \texttt{literature/}: hardware reference PDFs for VIC, timers, and ARM toolchain.
  \item \texttt{Dockerfile} and \texttt{Dockerfile.dev}: containerized build flows.
\end{itemize}
